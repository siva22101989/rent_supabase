'use server';

import { createClient } from '@/utils/supabase/server';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import { getUserWarehouse } from './data';

export type ActionState = {
  message: string;
  success: boolean;
  data?: any;
};

// --- Warehouse Management ---

export async function createWarehouse(name: string, location: string, capacity: number, email?: string, phone?: string): Promise<ActionState> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return { message: 'Unauthorized', success: false };

    // 1. Create Warehouse via Secure RPC
    const { data: warehouseId, error } = await supabase.rpc('create_new_warehouse', {
        p_name: name,
        p_location: location,
        p_capacity: capacity,
        p_email: email,
        p_phone: phone
    });

    if (error) return { message: 'Failed to create warehouse: ' + error.message, success: false };

    // 2. Switch Context
    await switchWarehouse(warehouseId);

    revalidatePath('/', 'layout');
    return { message: 'Warehouse created!', success: true, data: { id: warehouseId } };
}



export async function switchWarehouse(warehouseId: string): Promise<ActionState> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return { message: 'Unauthorized', success: false };

    // Verify Access
    const { data: access } = await supabase
        .from('warehouse_assignments')
        .select('role')
        .eq('user_id', user.id)
        .eq('warehouse_id', warehouseId)
        .single();

    if (!access) return { message: 'Access Denied', success: false };

    // Update Profile
    const { error } = await supabase
        .from('profiles')
        .update({ warehouse_id: warehouseId })
        .eq('id', user.id);

    if (error) return { message: 'Failed to switch: ' + error.message, success: false };

    revalidatePath('/', 'layout');
    return { message: 'Switched successfully', success: true };
}

export async function getUserWarehouses() {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return [];

    // Join assignments with warehouses
    const { data, error } = await supabase
        .from('warehouse_assignments')
        .select(`
            role,
            warehouse_id,
            warehouses (
                id,
                name,
                location
            )
        `)
        .eq('user_id', user.id);

    if (error) {
        console.error("Fetch warehouses error:", error);
        return [];
    }

    return data.map((d: any) => ({
        id: d.warehouse_id,
        role: d.role,
        name: d.warehouses?.name || 'Unknown',
        location: d.warehouses?.location || ''
    }));
}

export async function getActiveWarehouseId() {
   return getUserWarehouse();
}


// --- Invitations (Magic Links) ---

export async function generateInviteLink(role: 'admin' | 'staff' = 'staff'): Promise<ActionState> {
    const supabase = await createClient();
    const warehouseId = await getUserWarehouse();
    if (!warehouseId) return { message: 'No active warehouse', success: false };

    // Check Permissions (Owner/Admin only) - Enforced by RLS, but safe check here
    // ...

    const { data, error } = await supabase
        .from('warehouse_invitations')
        .insert({
            warehouse_id: warehouseId,
            role,
            // token generated by default
        })
        .select('token')
        .single();

    if (error) return { message: 'Failed to generate link', success: false };

    // Return the full URL (assuming current host is origin)
    // We can just return the token and let UI build the link to avoid host issues in server actions
    return { message: 'Link generated', success: true, data: { token: data.token } };
}

export async function joinWarehouse(token: string): Promise<ActionState> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return { message: 'Please login to join', success: false };

    // 1. Verify Token & Get Details (Security Definer logic simulated here via privileged client or RLS check)
    // Since we didn't open SELECT RLS for everyone, we might need a specific RPC or temporarilly use admin to read.
    // However, since we are accepting it, we can just try to "Claim" it via a Transaction/RPC.
    
    // Better approach: RPC 'claim_invite'
    const { data, error } = await supabase.rpc('claim_warehouse_invite', {
        p_token: token,
        p_user_id: user.id
    });

    if (error) return { message: error.message, success: false };

    // Switch to new warehouse immediately
    // The RPC returns warehouse_id
    await switchWarehouse(data); 

    revalidatePath('/', 'layout');
    return { message: 'Joined successfully!', success: true };
}

export async function leaveWarehouse(warehouseId: string): Promise<ActionState> {
     const supabase = await createClient();
     const { data: { user } } = await supabase.auth.getUser();
     if (!user) return { message: 'Unauthorized', success: false };

     const { error } = await supabase
        .from('warehouse_assignments')
        .delete()
        .eq('user_id', user.id)
        .eq('warehouse_id', warehouseId);

    if (error) return { message: 'Failed to leave', success: false };
    
    // Select another warehouse or set null?
    // ... logic to pick partial, or set to null
    await supabase.from('profiles').update({ warehouse_id: null }).eq('id', user.id);

    revalidatePath('/', 'layout');
    return { message: 'Left warehouse', success: true };
}
