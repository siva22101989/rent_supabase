'use server';

import { createClient } from '@/utils/supabase/server';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import { getUserWarehouse } from './data';

export type ActionState = {
  message: string;
  success: boolean;
  data?: any;
};

// --- Warehouse Management ---

export async function createWarehouse(name: string, location: string, capacity: number, email?: string, phone?: string): Promise<ActionState> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return { message: 'Unauthorized', success: false };

    // 1. Create Warehouse via Secure RPC
    const { data: warehouseId, error } = await supabase.rpc('create_new_warehouse', {
        p_name: name,
        p_location: location,
        p_capacity: capacity,
        p_email: email,
        p_phone: phone
    });

    if (error) return { message: 'Failed to create warehouse: ' + error.message, success: false };

    // 2. Switch Context
    await switchWarehouse(warehouseId);

    revalidatePath('/', 'layout');
    return { message: 'Warehouse created!', success: true, data: { id: warehouseId } };
}



export async function switchWarehouse(warehouseId: string): Promise<ActionState> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return { message: 'Unauthorized', success: false };

    // Verify Access
    const { data: access } = await supabase
        .from('warehouse_assignments')
        .select('role')
        .eq('user_id', user.id)
        .eq('warehouse_id', warehouseId)
        .single();

    if (!access) return { message: 'Access Denied', success: false };

    // Update Profile
    const { error } = await supabase
        .from('profiles')
        .update({ 
            warehouse_id: warehouseId,
            role: access.role // Sync role
        })
        .eq('id', user.id);

    if (error) return { message: 'Failed to switch: ' + error.message, success: false };

    revalidatePath('/', 'layout');
    return { message: 'Switched successfully', success: true };
}

export async function getUserWarehouses() {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return [];

    // Join assignments with warehouses
    const { data, error } = await supabase
        .from('warehouse_assignments')
        .select(`
            role,
            warehouse_id,
            warehouses (
                id,
                name,
                location
            )
        `)
        .eq('user_id', user.id);

    if (error) {
        console.error("Fetch warehouses error:", error);
        return [];
    }

    return data.map((d: any) => ({
        id: d.warehouse_id,
        role: d.role,
        name: d.warehouses?.name || 'Unknown',
        location: d.warehouses?.location || ''
    }));
}

export async function getActiveWarehouseId() {
   return getUserWarehouse();
}


// --- Invitations (Magic Links) ---

export async function generateInviteLink(role: 'owner' | 'admin' | 'manager' | 'staff' = 'staff'): Promise<ActionState> {
    const supabase = await createClient();
    const warehouseId = await getUserWarehouse();
    if (!warehouseId) return { message: 'No active warehouse', success: false };

    // Check Permissions (Owner/Admin only) - Enforced by RLS, but safe check here
    // ...

    const { data, error } = await supabase
        .from('warehouse_invitations')
        .insert({
            warehouse_id: warehouseId,
            role,
            // token generated by default
        })
        .select('token')
        .single();

    if (error) return { message: 'Failed to generate link', success: false };

    // Return the full URL (assuming current host is origin)
    // We can just return the token and let UI build the link to avoid host issues in server actions
    return { message: 'Link generated', success: true, data: { token: data.token } };
}

export async function joinWarehouse(token: string): Promise<ActionState> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return { message: 'Please login to join', success: false };

    // 1. Verify Token & Get Details (Security Definer logic simulated here via privileged client or RLS check)
    // Since we didn't open SELECT RLS for everyone, we might need a specific RPC or temporarilly use admin to read.
    // However, since we are accepting it, we can just try to "Claim" it via a Transaction/RPC.
    
    // Better approach: RPC 'claim_invite'
    const { data, error } = await supabase.rpc('claim_warehouse_invite', {
        p_token: token,
        p_user_id: user.id
    });

    if (error) return { message: error.message, success: false };

    // Switch to new warehouse immediately
    // The RPC returns warehouse_id
    await switchWarehouse(data); 

    revalidatePath('/', 'layout');
    return { message: 'Joined successfully!', success: true };
}

export async function leaveWarehouse(warehouseId: string): Promise<ActionState> {
     const supabase = await createClient();
     const { data: { user } } = await supabase.auth.getUser();
     if (!user) return { message: 'Unauthorized', success: false };

     const { error } = await supabase
        .from('warehouse_assignments')
        .delete()
        .eq('user_id', user.id)
        .eq('warehouse_id', warehouseId);

    if (error) return { message: 'Failed to leave', success: false };
    
    // Select another warehouse or set null?
    await supabase.from('profiles').update({ warehouse_id: null }).eq('id', user.id);

    revalidatePath('/', 'layout');
    return { message: 'Left warehouse', success: true };
}

// Request Access Flow
export async function requestJoinWarehouse(adminEmail: string): Promise<ActionState> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return { message: 'Unauthorized', success: false };

    // 1. Find Admin/Owner User
    const { data: adminProfile } = await supabase
        .from('profiles')
        .select('id, warehouse_id')
        .eq('email', adminEmail)
        .in('role', ['admin', 'owner', 'super_admin']) // Allow owners and super admins too
        .single();
    
    if (!adminProfile || !adminProfile.warehouse_id) {
        return { message: 'Admin not found or has no warehouse.', success: false };
    }

    // 2. Check if already requesting or assigned?
    // We can skip this check and rely on Admin to ignore duplicates, or check notifications table.
    // Let's just insert.

    // 3. Create Notification
    const { error } = await supabase
        .from('notifications')
        .insert({
            user_id: adminProfile.id, // Target the Admin
            warehouse_id: adminProfile.warehouse_id,
            type: 'join_request',
            title: 'Staff Join Request',
            message: `User ${user.user_metadata?.full_name || 'Staff'} (${user.email}) requested to join.`,
            link: `/settings/team?approve_user=${user.id}&name=${encodeURIComponent(user.user_metadata?.full_name || '')}`,
            is_read: false
        });

    if (error) return { message: 'Failed to send request: ' + error.message, success: false };

    return { message: 'Request sent successfully', success: true };
}

export async function approveJoinRequest(notificationId: string, requesterId: string): Promise<ActionState> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return { message: 'Unauthorized', success: false };

    // 1. Verify Admin Access (ensure the notification belongs to this admin)
    const { data: notification } = await supabase
        .from('notifications')
        .select('*')
        .eq('id', notificationId)
        .eq('user_id', user.id)
        .single();
    
    if (!notification) return { message: 'Request not found or unauthorized', success: false };

    // 2. Assign User to Warehouse
    const warehouseId = notification.warehouse_id;
    
    const { error: assignError } = await supabase
        .from('warehouse_assignments')
        .insert({
            user_id: requesterId,
            warehouse_id: warehouseId,
            role: 'staff' // Default role for joiners
        });

    if (assignError) return { message: 'Failed to assign user: ' + assignError.message, success: false };

    // 3. Update User Profile (Set Active Warehouse & Role)
    await supabase.from('profiles').update({ 
        warehouse_id: warehouseId,
        role: 'staff' // Set role to staff as they are joining
    }).eq('id', requesterId);

    // 4. Delete Notification
    await supabase.from('notifications').delete().eq('id', notificationId);

    revalidatePath('/', 'layout');
    return { message: 'User approved successfully', success: true };
}

export async function rejectJoinRequest(notificationId: string): Promise<ActionState> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return { message: 'Unauthorized', success: false };

    const { error } = await supabase
        .from('notifications')
        .delete()
        .eq('id', notificationId)
        .eq('user_id', user.id);

    if (error) return { message: 'Failed to delete request', success: false };

    revalidatePath('/settings/team');
    return { message: 'Request rejected', success: true };
}
