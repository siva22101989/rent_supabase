-- Multi-Warehouse RBAC & Invitations

-- 1. Warehouse Assignments (Junction Table)
CREATE TABLE IF NOT EXISTS warehouse_assignments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    warehouse_id UUID REFERENCES warehouses(id) ON DELETE CASCADE,
    role TEXT CHECK (role IN ('owner', 'admin', 'staff')) DEFAULT 'staff',
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id, warehouse_id)
);

-- Auto-update updated_at for assignments
CREATE TRIGGER trg_warehouse_assignments_updated_at BEFORE UPDATE ON warehouse_assignments FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- 2. Warehouse Invitations (No-Email "Magic Link" Tokens)
CREATE TABLE IF NOT EXISTS warehouse_invitations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    warehouse_id UUID REFERENCES warehouses(id) ON DELETE CASCADE,
    role TEXT DEFAULT 'staff',
    token TEXT UNIQUE NOT NULL DEFAULT encode(gen_random_bytes(16), 'hex'), -- The magic access code
    created_by UUID REFERENCES auth.users(id),
    status TEXT CHECK (status IN ('pending', 'accepted', 'expired')) DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    claimed_by UUID REFERENCES auth.users(id)
);

-- Auto-update updated_at for invitations
CREATE TRIGGER trg_warehouse_invitations_updated_at BEFORE UPDATE ON warehouse_invitations FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();


-- 3. Backfill: Assign current users as OWNERS of their current warehouse
-- This ensures no interruption in service.
INSERT INTO warehouse_assignments (user_id, warehouse_id, role)
SELECT 
    id as user_id, 
    warehouse_id, 
    'owner' as role
FROM profiles 
WHERE warehouse_id IS NOT NULL
ON CONFLICT (user_id, warehouse_id) DO NOTHING;


-- 4. RLS Implementation for Security

-- Enable RLS
ALTER TABLE warehouse_assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE warehouse_invitations ENABLE ROW LEVEL SECURITY;

-- POLICIES for warehouse_assignments

-- Users can view their own assignments to know which warehouses they can access
CREATE POLICY "Users receive their own assignments" 
ON warehouse_assignments FOR SELECT 
TO authenticated 
USING (auth.uid() = user_id);

-- Owners/Admins can view ALL assignments for warehouses they manage (to see staff list)
CREATE POLICY "Managers view warehouse members" 
ON warehouse_assignments FOR SELECT 
TO authenticated 
USING (
    EXISTS (
        SELECT 1 FROM warehouse_assignments wa 
        WHERE wa.warehouse_id = warehouse_assignments.warehouse_id 
        AND wa.user_id = auth.uid() 
        AND wa.role IN ('owner', 'admin')
    )
);

-- Owners/Admins can INSERT/UPDATE/DELETE members in their warehouses
CREATE POLICY "Managers manage warehouse members" 
ON warehouse_assignments FOR ALL 
TO authenticated 
USING (
    EXISTS (
        SELECT 1 FROM warehouse_assignments wa 
        WHERE wa.warehouse_id = warehouse_assignments.warehouse_id 
        AND wa.user_id = auth.uid() 
        AND wa.role IN ('owner', 'admin')
    )
);

-- POLICIES for warehouse_invitations

-- Any authenticated user can READ a pending invitation if they have the token (Logic handled in backend usually, but for SELECT)
-- Actually, strict security: Only managers should see the list of generated invites.
CREATE POLICY "Managers view outgoing invites" 
ON warehouse_invitations FOR SELECT 
TO authenticated 
USING (
    EXISTS (
        SELECT 1 FROM warehouse_assignments wa 
        WHERE wa.warehouse_id = warehouse_invitations.warehouse_id 
        AND wa.user_id = auth.uid() 
        AND wa.role IN ('owner', 'admin')
    )
);

-- Managers can create invites
CREATE POLICY "Managers create invites" 
ON warehouse_invitations FOR INSERT 
TO authenticated 
WITH CHECK (
    EXISTS (
        SELECT 1 FROM warehouse_assignments wa 
        WHERE wa.warehouse_id = warehouse_invitations.warehouse_id 
        AND wa.user_id = auth.uid() 
        AND wa.role IN ('owner', 'admin')
    )
);

-- Public (Anonymous) or Auth users can READ an invite by TOKEN to verify it (for the Join Page)
-- This requires a function or open policy for specific token lookup, or we keep it authenticated.
-- Let's keep it authenticated: User must be logged in to Join. 
-- So 'authenticated' users can see an invite IF they know the token? 
-- RLS doesn't easily support "if query has token". 
-- Instead, we will use a SECURITY DEFINER function in backend to verify tokens.
-- So we won't add a broad SELECT policy for invites here.
-- RPC to safely claim an invitation
CREATE OR REPLACE FUNCTION claim_warehouse_invite(p_token TEXT, p_user_id UUID)
RETURNS UUID AS $$
DECLARE
    v_invite warehouse_invitations%ROWTYPE;
BEGIN
    -- 1. Find valid pending invite
    SELECT * INTO v_invite
    FROM warehouse_invitations
    WHERE token = p_token AND status = 'pending';

    IF v_invite.id IS NULL THEN
        RAISE EXCEPTION 'Invalid or expired invitation link.';
    END IF;

    -- 2. Create Assignment
    INSERT INTO warehouse_assignments (user_id, warehouse_id, role)
    VALUES (p_user_id, v_invite.warehouse_id, v_invite.role)
    ON CONFLICT (user_id, warehouse_id) DO NOTHING; -- Idempotent if already joined

    -- 3. Mark Invite as Accepted
    -- Note: If we want multi-use links (e.g. "Staff Link"), we shouldn't mark as accepted.
    -- The schema implies single-use (claimed_by).
    -- User requested "Copy Link" which usually implies Multi-Use.
    -- Let's change behavior: Allow infinite uses for "staff" links, maybe single use for "admin"?
    -- Or just keep it single use for now and generate new ones? 
    -- "Copy Invite Link" implies a generic link for the team.
    -- Let's NOT expire it immediately if we want it to be reusable.
    -- But for security, re-usable links are risky if leaked.
    -- Let's make it RE-USABLE for now to support "WhatsApp to group" flow easier.
    -- So we just log the claim? Or do nothing to the invite?
    
    -- Modification: Don't set status = 'accepted' to keep it open.
    -- Just log? Or do nothing.
    
    RETURN v_invite.warehouse_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Fix RLS to allow viewing ALL assigned warehouses, not just the active one.

-- The existing policy "Staff Read Own" restricts users to only see the warehouse strictly matching profiles.warehouse_id.
-- This breaks the "Switch Warehouse" list because users cannot see names of other warehouses they own/joined.

-- 1. Drop the restrictive policy (or keep it if it serves a differnet purpose, but the new one essentially supercedes it for Reads)
-- Actually, let's keep it but add a broader one. Or just replace it?
-- "Staff Read Own" is quite specific. Let's add "Members View Assigned Warehouses".

CREATE POLICY "Members view assigned warehouses" 
ON warehouses FOR SELECT 
TO authenticated 
USING (
    EXISTS (
        SELECT 1 FROM warehouse_assignments wa 
        WHERE wa.warehouse_id = warehouses.id 
        AND wa.user_id = auth.uid()
    )
);

-- Note: The existing "Staff Read Own" is redundant now for SELECT if we have this, but fine to leave as backup.
-- Note: "Admin All" handles admins.
-- Fix RLS Infinite Recursion
-- The "Managers view/manage warehouse members" policies were querying warehouse_assignments recursively.
-- We fix this by moving the permission check to a SECURITY DEFINER function.

CREATE OR REPLACE FUNCTION public.has_role_on_warehouse(target_warehouse_id UUID, required_roles TEXT[])
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 
        FROM warehouse_assignments 
        WHERE warehouse_id = target_warehouse_id
        AND user_id = auth.uid()
        AND role = ANY(required_roles)
    );
END;
$$;

-- Drop problematic recursive policies
DROP POLICY IF EXISTS "Managers view warehouse members" ON warehouse_assignments;
DROP POLICY IF EXISTS "Managers manage warehouse members" ON warehouse_assignments;

-- Re-create them using the safe function
CREATE POLICY "Managers view warehouse members" 
ON warehouse_assignments FOR SELECT 
TO authenticated 
USING (
    has_role_on_warehouse(warehouse_id, ARRAY['owner', 'admin'])
);

CREATE POLICY "Managers manage warehouse members" 
ON warehouse_assignments FOR ALL 
TO authenticated 
USING (
    has_role_on_warehouse(warehouse_id, ARRAY['owner', 'admin'])
);

-- Note: "Users receive their own assignments" remains valid and non-recursive.
-- Seed Initial Data for the primary warehouse
-- Warehouse ID: a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11 (Sri Laksmi Warehouse)

-- 1. Crops
INSERT INTO crops (warehouse_id, name, bag_weight_kg, rent_6m, rent_1y)
VALUES
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Paddy', 75, 30.00, 50.00),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Maize', 100, 35.00, 55.00),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Groundnut', 40, 25.00, 45.00),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Red Gram', 100, 40.00, 60.00)
ON CONFLICT DO NOTHING; -- Avoid duplicates if re-run

-- 2. Warehouse Lots
INSERT INTO warehouse_lots (warehouse_id, name, capacity, cleanup_status)
VALUES
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Lot A', 1000, 'clean'),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Lot B', 1000, 'clean'),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Lot C', 1500, 'pending')
ON CONFLICT DO NOTHING;
-- Seed Initial Data for the primary warehouse (Corrected Columns)
-- Warehouse ID: a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11 (Sri Laksmi Warehouse)

-- 1. Crops
INSERT INTO crops (warehouse_id, name, standard_bag_weight_kg, rent_price_6m, rent_price_1y)
VALUES
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Paddy', 75, 30.00, 50.00),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Maize', 100, 35.00, 55.00),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Groundnut', 40, 25.00, 45.00),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Red Gram', 100, 40.00, 60.00)
ON CONFLICT DO NOTHING;

-- 2. Warehouse Lots
INSERT INTO warehouse_lots (warehouse_id, name, capacity, cleanup_status)
VALUES
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Lot A', 1000, 'clean'),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Lot B', 1000, 'clean'),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Lot C', 1500, 'pending')
ON CONFLICT DO NOTHING;
-- 1. Drop unused column from crops
ALTER TABLE crops DROP COLUMN IF EXISTS standard_bag_weight_kg;

-- 2. Seed Initial Data (Final Corrected Version)
-- Warehouse ID: a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11 (Sri Laksmi Warehouse)

-- Crops (No weight column)
INSERT INTO crops (warehouse_id, name, rent_price_6m, rent_price_1y)
VALUES
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Paddy', 30.00, 50.00),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Maize', 35.00, 55.00),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Groundnut', 25.00, 45.00),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Red Gram', 40.00, 60.00)
ON CONFLICT DO NOTHING;

-- Warehouse Lots (using 'status' instead of cleanup_status)
INSERT INTO warehouse_lots (warehouse_id, name, capacity, status)
VALUES
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Lot A', 1000, 'active'),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Lot B', 1000, 'active'),
    ('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Lot C', 1500, 'maintenance')
ON CONFLICT DO NOTHING;
-- Create Warehouse RPC (Security Definer)
-- Allows authenticated users to create a warehouse and instantly become its owner.
-- Bypasses the "chicken and egg" RLS problem.

CREATE OR REPLACE FUNCTION public.create_new_warehouse(
    p_name TEXT, 
    p_location TEXT, 
    p_capacity INTEGER,
    p_email TEXT DEFAULT NULL,
    p_phone TEXT DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    new_warehouse_id UUID;
BEGIN
    -- 1. Insert Warehouse
    INSERT INTO warehouses (name, location, capacity_bags, email, phone)
    VALUES (p_name, p_location, p_capacity, p_email, p_phone)
    RETURNING id INTO new_warehouse_id;

    -- 2. Assign Creator as Owner
    INSERT INTO warehouse_assignments (user_id, warehouse_id, role)
    VALUES (auth.uid(), new_warehouse_id, 'owner');

    RETURN new_warehouse_id;
END;
$$;

-- Auto-assign users to warehouses if their email matches the warehouse email
-- This handles legacy/manual creation cases.

-- 1. Insert into warehouse_assignments if not exists
INSERT INTO warehouse_assignments (user_id, warehouse_id, role)
SELECT p.id, w.id, 'owner'
FROM profiles p
JOIN warehouses w ON p.email = w.email
WHERE NOT EXISTS (
    SELECT 1 FROM warehouse_assignments wa 
    WHERE wa.user_id = p.id AND wa.warehouse_id = w.id
);

-- 2. Update profiles.warehouse_id now that assignments exist (or just match directly)
UPDATE profiles
SET warehouse_id = w.id
FROM warehouses w
WHERE profiles.email = w.email
AND profiles.warehouse_id IS NULL;

-- Prevent "No Warehouse" issues in the future
-- Trigger: When a user is assigned to a warehouse, automatically update their profile.warehouse_id
-- This ensures the Admin Panel query (which relies on profiles.warehouse_id) always has data.

CREATE OR REPLACE FUNCTION public.sync_profile_warehouse()
RETURNS TRIGGER AS $$
BEGIN
    -- Update the profile's warehouse_id to the newly assigned warehouse
    -- We only do this if it's an 'owner', 'admin', or 'manager' role assignment, 
    -- OR if the profile currently has NO warehouse.
    -- This strategy prioritizes "Management" roles as the primary link.
    
    IF NEW.role IN ('owner', 'admin', 'manager') OR (SELECT warehouse_id FROM profiles WHERE id = NEW.user_id) IS NULL THEN
        UPDATE profiles
        SET warehouse_id = NEW.warehouse_id
        WHERE id = NEW.user_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_warehouse_assignment_created ON warehouse_assignments;

CREATE TRIGGER on_warehouse_assignment_created
AFTER INSERT OR UPDATE ON warehouse_assignments
FOR EACH ROW
EXECUTE FUNCTION public.sync_profile_warehouse();

-- Enable RLS on customers
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;

-- Drop existing policies to avoid conflicts (optional, or use IF NOT EXISTS logic)
DROP POLICY IF EXISTS "Users view customers of their warehouse" ON customers;

-- Create Policy: Users can view customers if they are assigned to the warehouse
CREATE POLICY "Users view customers of their warehouse"
ON customers FOR SELECT
TO authenticated
USING (
    warehouse_id IN (
        SELECT warehouse_id FROM warehouse_assignments 
        WHERE user_id = auth.uid()
    )
    OR 
    warehouse_id IN (
        SELECT warehouse_id FROM profiles
        WHERE id = auth.uid()
    )
);

-- Policy for Insert/Update/Delete (Managers only)
CREATE POLICY "Managers manage customers"
ON customers FOR ALL
TO authenticated
USING (
    warehouse_id IN (
        SELECT warehouse_id FROM warehouse_assignments 
        WHERE user_id = auth.uid() 
        AND role IN ('owner', 'admin')
    )
);

-- Fix incorrect roles for backfilled customers
-- All users with @rentapp.local are customers, but were created as 'staff' by default trigger

UPDATE profiles
SET role = 'customer'
WHERE email LIKE '%@rentapp.local' AND role = 'staff';

-- Also ensure their warehouse_id is synced if possible?
-- For now, purely fixing the role removes them from the Admin Panel "Staff" view (due to our filter).

-- Sync warehouse_id from customers table to profiles table
-- This ensures 'Customer' users are linked to their Warehouse in the profiles table too.

UPDATE profiles
SET warehouse_id = customers.warehouse_id
FROM customers
WHERE profiles.id = customers.linked_user_id
AND profiles.warehouse_id IS NULL;

-- Sync warehouse_id from warehouse_assignments to profiles
-- This fixes the "No Warehouse" display in Admin Panel for Owners/Admins who are assigned via the new RBAC system

UPDATE profiles
SET warehouse_id = (
    SELECT warehouse_id 
    FROM warehouse_assignments 
    WHERE user_id = profiles.id 
    ORDER BY created_at DESC 
    LIMIT 1
)
WHERE warehouse_id IS NULL
AND EXISTS (
    SELECT 1 FROM warehouse_assignments WHERE user_id = profiles.id
);

-- Drop previous policies to update them
DROP POLICY IF EXISTS "Users view customers of their warehouse" ON customers;
DROP POLICY IF EXISTS "Managers manage customers" ON customers;

-- 1. READ POLICY (Select)
-- Staff/Admin/Owner: See own warehouse
-- Super Admin: See ALL
CREATE POLICY "Users view customers of their warehouse"
ON customers FOR SELECT
TO authenticated
USING (
    -- 1. Super Admin Bypass
    (SELECT role FROM profiles WHERE id = auth.uid()) = 'super_admin'
    OR
    -- 2. Assigned Warehouse
    warehouse_id IN (
        SELECT warehouse_id FROM warehouse_assignments 
        WHERE user_id = auth.uid()
    )
    OR 
    -- 3. Profile Warehouse (Legacy)
    warehouse_id IN (
        SELECT warehouse_id FROM profiles
        WHERE id = auth.uid()
    )
);

-- 2. WRITE POLICY (Insert/Update/Delete)
-- Admin/Owner: Manage own warehouse
-- Super Admin: Manage ALL
CREATE POLICY "Managers manage customers"
ON customers FOR ALL
TO authenticated
USING (
    -- 1. Super Admin Bypass
    (SELECT role FROM profiles WHERE id = auth.uid()) = 'super_admin'
    OR
    -- 2. Assigned Manager
    warehouse_id IN (
        SELECT warehouse_id FROM warehouse_assignments 
        WHERE user_id = auth.uid() 
        AND role IN ('owner', 'admin')
    )
);
-- Additional Performance Indexes
-- Created: 2025-12-27
-- Purpose: Add missing indexes for transactions and audit logs

-- Accelerate transaction lookups by record
CREATE INDEX IF NOT EXISTS idx_transactions_record_id ON withdrawal_transactions(storage_record_id);

-- Accelerate transaction date range queries (DESC for recent-first queries)
CREATE INDEX IF NOT EXISTS idx_transactions_date ON withdrawal_transactions(withdrawal_date DESC);

-- Accelerate payment date queries
CREATE INDEX IF NOT EXISTS idx_payments_date ON payments(payment_date DESC);

-- Accelerate customer phone lookups (for SMS and search)
CREATE INDEX IF NOT EXISTS idx_customers_phone ON customers(phone);

-- Accelerate audit log queries by user
CREATE INDEX IF NOT EXISTS idx_activity_logs_user_id ON activity_logs(user_id);

-- Accelerate audit log time-based queries
CREATE INDEX IF NOT EXISTS idx_activity_logs_created_at ON activity_logs(created_at DESC);

-- Performance Indexes for RENT Application

-- 1. Accelerate overall filtering by warehouse (Used in almost every query)
CREATE INDEX IF NOT EXISTS idx_storage_records_warehouse_id ON storage_records(warehouse_id);
CREATE INDEX IF NOT EXISTS idx_customers_warehouse_id ON customers(warehouse_id);
CREATE INDEX IF NOT EXISTS idx_expenses_warehouse_id ON expenses(warehouse_id);

-- REMOVED: payments table does not have warehouse_id column. 
-- It links via storage_record_id which is indexed below.

-- 2. Accelerate 'Active Records' queries (Used in Outflow, Dashboard, Storage Page)
-- This partial index is very powerful for "Show me current stock" queries
CREATE INDEX IF NOT EXISTS idx_storage_records_active ON storage_records(warehouse_id) WHERE storage_end_date IS NULL;

-- 3. Accelerate Customer History lookups (Used in Customer Details & Financial Aggregation)
CREATE INDEX IF NOT EXISTS idx_storage_records_customer_id ON storage_records(customer_id);

-- 4. Accelerate Payment lookups (Used in total_paid calculations in logic and views)
CREATE INDEX IF NOT EXISTS idx_payments_storage_record_id ON payments(storage_record_id);

-- 5. Accelerate Search by Record Number (Used in Outflow Selector)
-- Creating a standard btree index on the text cast might help if we used expression index,
-- but standard column index is usually sufficient if we search often.
CREATE INDEX IF NOT EXISTS idx_storage_records_record_number ON storage_records(record_number);
-- Create a robust view for Customer Financials
-- This moves the heavy "Reduce" logic from JavaScript (Client) to Postgres (Server)

create or replace view customer_balances as
select 
    c.id as customer_id,
    c.warehouse_id,
    c.name as customer_name,
    c.phone,
    
    -- Total Billed = Sum of (Hamali + Rent) from all storage records
    coalesce(sum(sr.hamali_payable), 0) + coalesce(sum(sr.total_rent_billed), 0) as total_billed,
    
    -- Total Paid = Sum of all payments linked to these records
    coalesce(
        (
            select sum(p.amount)
            from payments p
            inner join storage_records sr2 on p.storage_record_id = sr2.id
            where sr2.customer_id = c.id
        ), 
        0
    ) as total_paid,
    
    -- Balance = Billed - Paid
    (
        (coalesce(sum(sr.hamali_payable), 0) + coalesce(sum(sr.total_rent_billed), 0)) -
        coalesce(
            (
                select sum(p.amount)
                from payments p
                inner join storage_records sr2 on p.storage_record_id = sr2.id
                where sr2.customer_id = c.id
            ), 
            0
        )
    ) as balance,

    -- Count of Active Records (where storage_end_date is null)
    count(case when sr.storage_end_date is null then 1 end) as active_records_count

from customers c
left join storage_records sr on c.id = sr.customer_id
group by c.id, c.warehouse_id, c.name, c.phone;
-- SMS Settings Table
-- Stores user preferences for SMS notifications

CREATE TABLE IF NOT EXISTS sms_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    warehouse_id UUID NOT NULL REFERENCES warehouses(id) ON DELETE CASCADE,
    
    -- Feature toggles
    enable_payment_reminders BOOLEAN DEFAULT true,
    enable_inflow_welcome BOOLEAN DEFAULT false,
    enable_outflow_confirmation BOOLEAN DEFAULT false,
    enable_payment_confirmation BOOLEAN DEFAULT false,
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Ensure one settings row per warehouse
    UNIQUE(warehouse_id)
);

-- Enable RLS
ALTER TABLE sms_settings ENABLE ROW LEVEL SECURITY;

-- Policy: Users can view their warehouse settings
CREATE POLICY "Users can view their warehouse SMS settings"
    ON sms_settings
    FOR SELECT
    USING (
        warehouse_id IN (
            SELECT warehouse_id FROM user_warehouses WHERE user_id = auth.uid()
        )
    );

-- Policy: Admins can update their warehouse settings
-- Policy: Admins can update their warehouse settings
CREATE POLICY "Admins can update their warehouse SMS settings"
    ON sms_settings
    FOR UPDATE
    USING (
        warehouse_id IN (
            SELECT warehouse_id 
            FROM user_warehouses 
            WHERE user_id = auth.uid()
            AND role IN ('super_admin', 'owner', 'admin')
        )
    );

-- Policy: Admins can insert their warehouse settings
CREATE POLICY "Admins can insert their warehouse SMS settings"
    ON sms_settings
    FOR INSERT
    WITH CHECK (
        warehouse_id IN (
            SELECT warehouse_id 
            FROM user_warehouses 
            WHERE user_id = auth.uid()
            AND role IN ('super_admin', 'owner', 'admin')
        )
    );

-- Create default settings for existing warehouses
INSERT INTO sms_settings (warehouse_id, enable_payment_reminders)
SELECT id, true FROM warehouses
ON CONFLICT (warehouse_id) DO NOTHING;

-- Add comment
COMMENT ON TABLE sms_settings IS 'SMS notification preferences per warehouse';
-- Migration: Add Commodity Price Tracking Tables
-- Description: Stores AGMARKNET commodity prices and user watchlists
-- Created: 2024-12-25

-- Enable UUID extension if not already enabled
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Table: commodity_prices
-- Stores historical commodity price data from AGMARKNET
CREATE TABLE IF NOT EXISTS commodity_prices (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    commodity VARCHAR(100) NOT NULL,
    variety VARCHAR(100),
    market VARCHAR(200) NOT NULL,
    state VARCHAR(50) NOT NULL,
    district VARCHAR(100),
    min_price DECIMAL(10,2),
    max_price DECIMAL(10,2),
    modal_price DECIMAL(10,2), -- Most common/average price
    arrival_quantity DECIMAL(10,2), -- In quintals
    price_date DATE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Ensure unique price entry per commodity-market-date
    CONSTRAINT unique_commodity_price UNIQUE(commodity, market, price_date)
);

-- Table: user_commodity_watchlist
-- Stores user's tracked commodities for price monitoring
CREATE TABLE IF NOT EXISTS user_commodity_watchlist (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    warehouse_id UUID NOT NULL REFERENCES warehouses(id) ON DELETE CASCADE,
    commodity VARCHAR(100) NOT NULL,
    variety VARCHAR(100),
    preferred_market VARCHAR(200), -- User's local market
    preferred_state VARCHAR(50),
    alert_threshold DECIMAL(10,2), -- Alert when modal_price >= threshold
    alert_enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Ensure user can't add same commodity twice for same warehouse
    CONSTRAINT unique_user_commodity UNIQUE(user_id, warehouse_id, commodity)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_commodity_prices_lookup 
    ON commodity_prices(commodity, price_date DESC);

CREATE INDEX IF NOT EXISTS idx_commodity_prices_market 
    ON commodity_prices(market, price_date DESC);

CREATE INDEX IF NOT EXISTS idx_commodity_prices_state 
    ON commodity_prices(state, commodity, price_date DESC);

CREATE INDEX IF NOT EXISTS idx_watchlist_user 
    ON user_commodity_watchlist(user_id, warehouse_id);

CREATE INDEX IF NOT EXISTS idx_watchlist_commodity 
    ON user_commodity_watchlist(commodity);

-- Function: Update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers for updated_at
CREATE TRIGGER update_commodity_prices_updated_at
    BEFORE UPDATE ON commodity_prices
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_watchlist_updated_at
    BEFORE UPDATE ON user_commodity_watchlist
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Row Level Security (RLS) Policies

-- Enable RLS
ALTER TABLE commodity_prices ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_commodity_watchlist ENABLE ROW LEVEL SECURITY;

-- Commodity Prices: Read-only for all authenticated users
CREATE POLICY "Anyone can view commodity prices"
    ON commodity_prices
    FOR SELECT
    TO authenticated
    USING (true);

-- Commodity Prices: Only service role can insert/update
CREATE POLICY "Service role can manage commodity prices"
    ON commodity_prices
    FOR ALL
    TO service_role
    USING (true)
    WITH CHECK (true);

-- Watchlist: Users can only see their own watchlist
CREATE POLICY "Users can view own watchlist"
    ON user_commodity_watchlist
    FOR SELECT
    TO authenticated
    USING (auth.uid() = user_id);

-- Watchlist: Users can insert their own watchlist items
CREATE POLICY "Users can create own watchlist items"
    ON user_commodity_watchlist
    FOR INSERT
    TO authenticated
    WITH CHECK (auth.uid() = user_id);

-- Watchlist: Users can update their own watchlist items
CREATE POLICY "Users can update own watchlist items"
    ON user_commodity_watchlist
    FOR UPDATE
    TO authenticated
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

-- Watchlist: Users can delete their own watchlist items
CREATE POLICY "Users can delete own watchlist items"
    ON user_commodity_watchlist
    FOR DELETE
    TO authenticated
    USING (auth.uid() = user_id);

-- Insert sample data for testing (optional - remove in production)
-- This helps developers test the feature without waiting for API sync
INSERT INTO commodity_prices (commodity, variety, market, state, district, min_price, max_price, modal_price, arrival_quantity, price_date)
VALUES 
    ('Wheat', 'Lokwan', 'Ludhiana', 'Punjab', 'Ludhiana', 2300.00, 2500.00, 2400.00, 1500.00, CURRENT_DATE),
    ('Rice', 'Basmati', 'Karnal', 'Haryana', 'Karnal', 3000.00, 3300.00, 3150.00, 2000.00, CURRENT_DATE),
    ('Wheat', 'Lokwan', 'Ludhiana', 'Punjab', 'Ludhiana', 2250.00, 2450.00, 2350.00, 1600.00, CURRENT_DATE - INTERVAL '1 day'),
    ('Rice', 'Basmati', 'Karnal', 'Haryana', 'Karnal', 2950.00, 3250.00, 3100.00, 1900.00, CURRENT_DATE - INTERVAL '1 day')
ON CONFLICT (commodity, market, price_date) DO NOTHING;

-- Comments for documentation
COMMENT ON TABLE commodity_prices IS 'Stores daily commodity prices from AGMARKNET API';
COMMENT ON TABLE user_commodity_watchlist IS 'User-specific commodity watchlist for price tracking and alerts';
COMMENT ON COLUMN commodity_prices.modal_price IS 'Most common/average price in the market for that day';
COMMENT ON COLUMN commodity_prices.arrival_quantity IS 'Total quantity arrived in market (in quintals)';
COMMENT ON COLUMN user_commodity_watchlist.alert_threshold IS 'User will be notified when modal_price reaches or exceeds this value';
